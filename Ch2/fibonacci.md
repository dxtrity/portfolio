# Fibonacci
Let's start actually making something more exciting. In this chapter, we'll get to write a fibonacci program that takes in user input and outputs the fibonacci sequence corresponding to the input.

## Setting up a new Project
As with before, navigate to your projects folder, create a new folder ,then run `cog new fibonacci` to create a new project.

```bash | psh
mkdir fibonacci
cd fibonacci
cog new fibonacci
```

## Processing input
Let's start out by asking the user to input the amount of terms that the program should print out.
We will need to access the **standard library** (`core`) once again to access the `io` module.
From the `io` module we will need: `echo`, `listen` and `puts`. Let's do that now.

```gear
ref core::io::echo;         // Print text
ref core::io::puts;         // Print numbers
ref core::io::listen;       // Listen for input
```

The `echo` function let's us display `char` and `String`s to the standard output. While `puts` allows us to print out numbers like `int` or `float`. The final function, `listen` grabs input from the user via standard input.

First things first, let's get rid of the default *hello world* code that is generated by cog. Replace this with an `echo` that displays a message to the user and `listen` function that grabs the input from them.

```gear
func main() -> void {
    echo("Enter number of terms: ");
    let x:string = listen();
    let number_of_terms:int = x.toInt();
}
```

We declare a variable using the `let` keyword. We then state it's type and then assign a value. In this case, the name of the variable is `x`. A good practice is to use underscores to split up variable names that have multiple words.

The key concept to learn here is that: by default in Gear, variables are immutable. You tell the compiler when a variable may change otherwise it presumes it doesn't. We do this by adding an exclamation mark (`!`) to the front of the variables name.

If you go to compile the current code. You may realise that your IDE or compiler will give you an error. This is because Gear doesn't support the use of strings out the box. To use strings, we need to import the type from the `core` library.

We then use the `toInt` method on the `x` variable to convert the user input, which by default is a `string`, into an `int`. The method is available on any `string` type variable. We'll get to why we do this in a second.

```gear
ref core::io::echo;
ref core::io::puts;
ref core::io::listen;
ref core::string;       // String type implementation.
```

We will get into more detail as to why Gear doesn't support *strings* out the box later. But for now just know you have to import them.

```gear
let !n1:int = 0;
let !n2:int = 1;
let !count:int = 0;
```

Now we will declare a couple more needed variables within *main()*. `n1` is the first number. `n2` is the second number. `count` is a count of the current iteration. We need to iterate over the number of terms that the user entered. To do this, we will use a `while` loop.

```gear
if (number_of_terms <= 0) {
    echo("Please enter positive integer);
} else if (number_of_terms == 1) {
    echo("Fibonacci sequence:");
    puts(n1);
} else {
    ...
}
```

Before that however, let's make sure that the user hasn't entered negative numbers. And if the input is 1: lets just print `n1` which is 0. The way we do selection in Gear is similar to other curly-bracket languages. an `if` keyword then sorround a *condition* in parenthesis (`()`) and then put our code within curly brackets (`{}`).

We then add in an `else if` statement to check if the value is equal to 1. We then `echo` out *"Fibonacci sequence:"* and then *`n1`* which is 0.

Carrying on, we then add in `else` to handle what happens for anything other than those 2 conditions.

```gear
} else {
    echo("Fibonacci sequence:");
    while (count < number_of_terms) {
        puts(n1);
        let !nth:int = n1 + n2;
        n1 = n2;
        n2 = nth;
        count += 1;
    }
}
```

We output *"Fibonacci sequence"* via `echo` and then create a `while` loop which follows the same format as an `if` statement. The condition for the loop is: loop until `count` is greater than (`<`) `number_of_terms`. Inside the loop, we print out `n1` via `puts`. We then declare a new variable `nth` which is an integer. The `nth` value is `n1` plus (`+`) `n2`. We then change the value of `n1` to `n2` and `n2` to `nth`. We then increment (`+=`) the `count` variable by 1.

## Compiling and errors
And we're done! Woohoo! We can now run `cog build` to get a clean build of the project. However, we come to one issue. The compiler isn't happy that we don't check for potential errors and refuses to compile our code. The **unsafe** code in question is our use of `listen`. We don't check what happens if the user doesn't input a `string`.

We have 2 ways to fix the compiler error. One is to: Handle the error. Two is to: Tell the compiler to ignore that unsafe code. We will show you how to do both here.

```gear
ref core::io::fatal;

...

let x:string, err:error = listen();
if (err) { fatal("Please enter a string") }
```

We require the `fatal` function from the `io` module from the `core` library. This function allows us to throw fatal errors out to the user. The function also, safely, exits the program. We address the error by adding a `,` by the `x:string` value. And adding a `err:error` before the assignment of the variable. We then handle the error via an `if` statement declared after the variable. The condition is just `err` which is the name given to the error. We tell the compiler that `if` there is an error (`(err)`), print *"Please enter a string"* and then *exit* the program.

However, what if we didn't care? Or what if avoiding unsafe code was impossible. Which can be the case in certain scenarios. Well, that's where your `cogfile` comes in. Move over to your generated `cog` file and then declare that line unsafe:

```cog
name = "fibonacci"
version = "1.0.0"
cog = "0.1.0"

@unsafe
line:7
```

This will declare *line 7* as unsafe and will ignore any unhandled errors or unsafe operations made in the expression. We will go into more detail on how to use the `cogfile` to handle both errors and unsafe code in future chapters.

Voila! You can now compile successfully. Cog should no longer complain about any unsafe code and the compiler will produce a new executable file in your `build` folder. You can run it with:

```bash | psh
$ build/fibonacci
```